Go言語チュートリアル

# 型
Go言語にはつぎの四つの型が存在する．
1.基本型
2.合成型
3.参照型
4.インターフェース型

## 基本データ型
### 整数
int8, int16, int32, int64
uint8, uint16, uint32, uint64
int, uint, uintptr, byte, rune
符号付き整数と符号なし整数があり，
それぞれ異なる四つのサイズが用意されている．
またint及びuintは動作するプラットフォームで自然なサイズで動作する．
uintptrはポインタの値のすべてのビットを保持するには十分なサイズで定義されている．
int, uint, uintptrはその実際のサイズを当てにしたプログラムを書いてはならない．
byte及びruneはそれぞれint32, uint8に対するシノニムで，
前者はUnicodeのコードポイント，後者はバイナリデータを扱うためのものである．
#### 二項演算子
算術，論理，比較演算子は五段階の優先度順に以下のように定義されている．
* / % << >> & &^
+ - | ^
== != < <= > >=
&&
||

### 浮動小数点
float32, float64
Go言語には二つの浮動小数点数が定義されている．
float32による計算は注意しないと急速に誤差が蓄積される．
そのため通常はfloat64を使用する．
また，非常に大きい(小さい)数は数字の後にE[e]を使用して書くと便利．
例えば，プランク定数は次のように書ける．
const Planck = 6.62606957e-34

### 複素数
complex64, complex128
Go言語には二つの複素数型が定義されている．
それぞれfloat32, float64を実部と虚部に用いている型となる．
real及びimag関数でそれぞれ実部と虚部を取り出せる．
var x complex128 = complex(1, 2)    // 1+2i
var y complex128 = complex(3, 4)    // 3+4i
var z = x*y    // -5+10i
real(z)    // -5
imag(z)    // 10
また数字の後にiが続くと場合虚数リテラルと見做される．
そのため上記の宣言は
x := i + 2i
と書ける．

### ブーリアン
true, false
ブーリアンの値が取るのは真(true)か偽(false)かである．

### 文字列
文字列はダブルクォーテーションで囲まれたリテラルである．
また，リテラル内にバックスラッシュから始まるエスケープシーケンスが
定義されている．
\a, alert(ベル)
\b, backspace(バックスペース)
\f, form feed(フォームフィード)
\n, newline(改行)
\r, carriage return(キャリッジリターン)
\t, tab(タブ)
\v, vertical tab(垂直タブ)
\", ダブルクォーテーション
\\, バックスラッシュ
また，バッククォートで囲むと
上記のエスケープシーケンスが展開されない生文字列リテラルと見做される．


## コンポジット型
### 配列
<size> = \[(\d | \.{3})\]
<expression> = (<value> (,<value>)*
                | <index>:<value> (,<index>:<value>)*)
var <identifier> <size><type> [= <size>{<expression>}]
配列は特定の型の0個以上の固定長列である．
添字は0から始まる．
また，宣言と同時に初期化することができる．
このとき，配列リテラルを使用できる．
初期化時に`...'を大きさに指定した場合は初期化子の数で配列のサイズを定義する．
var arr [3]int = [3]int{1, 2, 3}
配列リテラルとして，添字と値のリストを与えることもできる．
var arr [...]string = [...]int{0:"foo", 1:"bar", 2:"buzz"}
配列を関数に渡すときは値渡しとなるため，注意が必要である．
ハードコピーを作りたくない場合はポインタで参照渡しをすること．

### スライス
スライスはすべての要素が同じ型の可変長列である．
可変長という点で配列と異なる．
厳密には，スライスはある配列の部分列全体の集合の元であり，
ポインタ，長さ，容量の三個の属性を持つデータ構造である．
スライスリテラルは波括弧に囲まれたカンマ区切りの一連の値である．
これは，暗黙に配列を生成しそのスライスを返す処理を行う．
#### スライスへ項目を追加する
append(<slice>, <value>)
ただし，呼び出し元にその値を代入すること．

### マップ
map[<K>]<V>
マップはハッシュテーブルへの参照である．
<K>, <V>はそれぞれキーと値の型を表す．
マップ内のキーと値の型はすべて同じである必要がある．
キーは次の条件を満たす必要がある．
1. `=='を用いて比較可能であること．
値には特に制約はない．
マップの生成は以下の記法を用いる．
<identifier> := make(map[<K>]<V>)
また，マップリテラルを利用して初期化も同時に行う場合は
<identifier> := map[<K>]<V> {
  <K1>: <V1>,
  <K2>: <V2>,
  ...
  <KN>: <VN>,
}
のように書ける．
このことは，空のマップを生成するには
<identifier> := make(map[<K>]<V>){}
と書けることを意味する．
#### マップの要素の追加
<identifier>[<K>] = <V>
この記法を用いると，上述のマップリテラルを用いた初期化は
<identifier> := make(map[<K>]<V>])
<identifier>[<K1>] = <V1>
<identifier>[<K2>] = <V2>
  ...
<identifier>[<KN>] = <VN>
と等価である．
#### マップの参照
<identifier>[<K>]
配列の要素を参照するように，<K>に紐づく<V>を参照することができる．
当該キーが存在しない場合は，<V>の型のゼロ値が返る．
#### マップの値の削除
delete(<identifier>, <K>)
組み込みのdelete関数を用いて要素をマップから取り除くことができる．
#### マップのイテレート
for <K>, <V> := range <map> {
  <expression>
}
ただし，マップの繰り返し順序は定義されていない．
#### `=='で比較不可能なキー値を持つマップ
マップのキーはその制約により`=='を用いて比較可能でなければならない．
しかし，`=='を用いた比較が不可能なキー値を設定したマップを用いたい場合がある．
そのようなマップはキー値を`=='で比較可能な値に変換する関数
mapKey: <==で比較不可能なキー値> -> <==で比較可能なキー値>
を定義することにより実現できる． ただし，mapKeyは全単射である必要がある．
すべてのマップの操作にあたり，mapKeyを介した処理を用いれば良い．

### 構造体


## 参照型
### ポインタ
### スライス
### 関数
### チャネル

## インターフェース型
