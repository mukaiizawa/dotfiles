Go言語チュートリアル

# 型
Go言語にはつぎの四つの型が存在する．
1.基本型
2.合成型
3.参照型
4.インターフェース型

## 基本データ型
### 整数
int8, int16, int32, int64
uint8, uint16, uint32, uint64
int, uint, uintptr, byte, rune
符号付き整数と符号なし整数があり，
それぞれ異なる四つのサイズが用意されている．
またint及びuintは動作するプラットフォームで自然なサイズで動作する．
uintptrはポインタの値のすべてのビットを保持するには十分なサイズで定義されている．
int, uint, uintptrはその実際のサイズを当てにしたプログラムを書いてはならない．
byte及びruneはそれぞれint32, uint8に対するシノニムで，
前者はUnicodeのコードポイント，後者はバイナリデータを扱うためのものである．
#### 二項演算子
算術，論理，比較演算子は五段階の優先度順に以下のように定義されている．
* / % << >> & &^
+ - | ^
== != < <= > >=
&&
||

### 浮動小数点
float32, float64
Go言語には二つの浮動小数点数が定義されている．
float32による計算は注意しないと急速に誤差が蓄積される．
そのため通常はfloat64を使用する．
また，非常に大きい(小さい)数は数字の後にE[e]を使用して書くと便利．
例えば，プランク定数は次のように書ける．
const Planck = 6.62606957e-34

### 複素数
complex64, complex128
Go言語には二つの複素数型が定義されている．
それぞれfloat32, float64を実部と虚部に用いている型となる．
real及びimag関数でそれぞれ実部と虚部を取り出せる．
var x complex128 = complex(1, 2)    // 1+2i
var y complex128 = complex(3, 4)    // 3+4i
var z = x*y    // -5+10i
real(z)    // -5
imag(z)    // 10
また数字の後にiが続くと場合虚数リテラルと見做される．
そのため上記の宣言は
x := i + 2i
と書ける．

### ブーリアン
true, false
ブーリアンの値が取るのは真(true)か偽(false)かである．

### 文字列
文字列はダブルクォーテーションで囲まれたリテラルである．
また，リテラル内にバックスラッシュから始まるエスケープシーケンスが
定義されている．
\a, alert(ベル)
\b, backspace(バックスペース)
\f, form feed(フォームフィード)
\n, newline(改行)
\r, carriage return(キャリッジリターン)
\t, tab(タブ)
\v, vertical tab(垂直タブ)
\", ダブルクォーテーション
\\, バックスラッシュ
また，バッククォートで囲むと
上記のエスケープシーケンスが展開されない生文字列リテラルと見做される．


## コンポジット型
### 配列
<size> = \[(\d | \.{3})\]
<expression> = (<value> (,<value>)*
                | <index>:<value> (,<index>:<value>)*)
var <identifier> <size><type> [= <size>{<expression>}]
配列は特定の型の0個以上の固定長列である．
添字は0から始まる．
また，宣言と同時に初期化することができる．
このとき，配列リテラルを使用できる．
初期化時に`...'を大きさに指定した場合は初期化子の数で配列のサイズを定義する．
var arr [3]int = [3]int{1, 2, 3}
配列リテラルとして，添字と値のリストを与えることもできる．
var arr [...]string = [...]int{0:"foo", 1:"bar", 2:"buzz"}
配列を関数に渡すときは値渡しとなるため，注意が必要である．
ハードコピーを作りたくない場合はポインタで参照渡しをすること．

### スライス
スライスはすべての要素が同じ型の可変長列である．
可変長という点で配列と異なる．
厳密には，スライスはある配列の部分列全体の集合の元であり，
ポインタ，長さ，容量の三個の属性を持つデータ構造である．
スライスリテラルは波括弧に囲まれたカンマ区切りの一連の値である．
これは，暗黙に配列を生成しそのスライスを返す処理を行う．
#### スライスへ項目を追加する
append(<slice>, <value>)
ただし，呼び出し元にその値を代入すること．

### マップ
map[<K>]<V>
マップはハッシュテーブルへの参照である．
<K>, <V>はそれぞれキーと値の型を表す．
マップ内のキーと値の型はすべて同じである必要がある．
キーは次の条件を満たす必要がある．
1. `=='を用いて比較可能であること．
値には特に制約はない．
マップの生成は以下の記法を用いる．
<identifier> := make(map[<K>]<V>)
また，マップリテラルを利用して初期化も同時に行う場合は
<identifier> := map[<K>]<V> {
  <K1>: <V1>,
  <K2>: <V2>,
  ...
  <KN>: <VN>,
}
のように書ける．
このことは，空のマップを生成するには
<identifier> := make(map[<K>]<V>){}
と書けることを意味する．
#### マップの要素の追加
<identifier>[<K>] = <V>
この記法を用いると，上述のマップリテラルを用いた初期化は
<identifier> := make(map[<K>]<V>])
<identifier>[<K1>] = <V1>
<identifier>[<K2>] = <V2>
  ...
<identifier>[<KN>] = <VN>
と等価である．
#### マップの参照
<identifier>[<K>]
配列の要素を参照するように，<K>に紐づく<V>を参照することができる．
当該キーが存在しない場合は，<V>の型のゼロ値が返る．
#### マップの値の削除
delete(<identifier>, <K>)
組み込みのdelete関数を用いて要素をマップから取り除くことができる．
#### マップのイテレート
for <K>, <V> := range <map> {
  <expression>
}
ただし，マップの繰り返し順序は定義されていない．
#### `=='で比較不可能なキー値を持つマップ
マップのキーはその制約により`=='を用いて比較可能でなければならない．
しかし，`=='を用いた比較が不可能なキー値を設定したマップを用いたい場合がある．
そのようなマップはキー値を`=='で比較可能な値に変換する関数
mapKey: <==で比較不可能なキー値> -> <==で比較可能なキー値>
を定義することにより実現できる． ただし，mapKeyは全単射である必要がある．
すべてのマップの操作にあたり，mapKeyを介した処理を用いれば良い．

### 構造体
type <identifier> struct {
  <field1> <type1>
  <field2> <type2>
  ...
  <fieldN> <typeN>
}
構造体は0個以上のフィールドを持つ合成型である．
フィールド名が大文字から始まる場合は
公開他のパッケージにも公開するフィールドと見做される．
この仕様は他にも一貫している．
#### 構造体の生成
<identifier> {
  <value1>,
  <value2>,
  ...
  <valueN>
}
宣言した構造体はすべてのフィールドに対して，
宣言した順序で初期値を指定することにより生成できる．
この方法は一般にはあまり使われず，代わりに次の構造体リテラル
<identifier> {
  <field1>: <value1>,
  <field2>: <value2>,
  ...
  <fieldN>: <valueN>
}
がよく使われる．
この記法では，初期値を指定しないフィールドの値は
そのフィールドの型のゼロ値が使用される点で異なる．
また，記述の順番は宣言した順番に縛られない．
これらの２つの異なる構造体リテラルは混ぜて使用することはできない．
#### 構造体のフィールドの参照
<identifier>.<field>
フィールドの参照はドット記法を用いる．
#### 構造体の比較
構造体のそれぞれのフィールドが`=='演算子で比較可能なとき，
比較可能な構造体という．
比較可能な構造体はマップのキー値として使用できる．
#### 構造体埋め込み
type <identifier> struct {
  ...
  <type>
  ...
}
構造体に無名のフィールドを定義することができる．
これを無名フィールドと呼ぶ．
無名フィールドの方は名前付き型か名前付き型へのポインタでなければならない．
無名フィールドを宣言することにより，
無名フィールドのフィールドへのアクセス記法が簡潔にすることができる．
即ち，
type A struct { x int }
type B struct { A }
b := B {}
b.x = 3    // b.A.xと書かなくてよい．
と書ける．

### 関数
<signature> = <identifier1>, <identifier2>, ... , <identifierN> <type>
<signatures> = <signature1>, <signature2>, ... , <signatureN>
func <identifier> (<signatures>) (<signatures>) {
  ...
}
関数宣言は関数名、引数リスト、返り値のリストにより構成される。
返り値のリストは、関数の返り値がない場合は省略できる。
また、返り値が1つの場合は括弧を省略できる。
引数リストと返り値のリストは同じ型が続く限り型の宣言を省略できる。
そのため、次の2つの記述は同じものと見做される。
func f(i, j, k int, s, t string) {}
func f(i int, j int, k int, s string, t string) {}
関数への引数は値渡しされる。
ただし、間接的に参照されている引数に変更を加えると呼び出し元にも影響が及ぶ。
#### 返り値が複数ある関数


## 参照型
### ポインタ
### スライス
### チャネル

## インターフェース型
