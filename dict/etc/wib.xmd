Worse is Better

# Worse is Better
私やCommon LispとCLOSのデザイナーのほとんどは、MIT/Stanford方式の設計に親しんでいる。 この方式の核心は、「正しい」やり方をせよ、ということにつきる。

デザイナーにとっては、以下の点をすべて正しく満たすことが重要である。

    簡潔性
    デザインは実装と使用法の両面において単純でなければならない。このとき、使用法が単純な方が実装が単純なことより重要である。
    正当性
    デザインはすべての点において正しいものでなければならない。誤りは許されない。
    一貫性
    デザインは一貫性を欠いたものであってはならない。一貫性を保つためには完全性は少しだけ犠牲にしてもよい。一貫性は正当性と同じぐらい重要である。
    完全性
    デザインは実際に起こる重要な状況にはすべて対応できなければならない。起こることが予想される場合はすべて扱えなければならない。簡潔さのために完全さが大きく損なわれることがあってはならない。

ほとんどの人がこの条件に同意されることと思う。このデザイン哲学を、以下「MITアプローチ」と呼ぶことにしたい。CommonLisp(とCLOS)やSchemeはこのデザイン哲学を体現している。

"悪い方がよい"原則はこれと少しだけ異なる：

    簡潔性
    デザインは実装と使用法の両面において単純でなければならない。このとき、実装が単純な方が使用法が単純なことより重要である。単純さがデザインにおいて最も重視されるべき事柄である。
    正当性
    デザインはすべての点において正しいものでなければならない。ただし、どちらかといえば、正しいことよりは単純なことの方が重要である。
    一貫性
    デザインは一貫性を大きく欠いたものであってはならない。単純さを保つために、一貫性は犠牲にされることがある。しかし、あまり起こらない状況に対応しようとして実装を複雑にしたり一貫性を欠いたものにするよりは、それを捨てる方がよい。
    完全性
    デザインは実際に起こる重要な状況にはすべて対応できなければならない。普通に起こると思われる場合はすべて扱えるべきである。ただし、他の条件のためならば完全さはいつでも犠牲にしてよい。さらに、実装の単純さが失われる場合には完全さを犠牲にしてもそれを守るべきである。単純さが保たれるならば、完全なものにするために一貫性を犠牲にしてもよい。
    何より意味がないのは、使用法の一貫性を守ることである。

初期のUnixとC言語はこのデザイン流派の例である。以下、このデザイン戦略を「NewJerseyアプローチ」と呼びたい。私はわざと「悪い方がよい」原則を悪く書き、これが明らかに悪い哲学であり、NewJerseyアプローチが悪いアプローチであることを信じるようにした。

しかし、私は「悪い方がよい」原則のほうが単純な場合でも「正しい」ことより生き残る哲学であり、ソフトウェア開発についてはNewJerseyアプローチの方がMITアプローチよりもよいアプローチだと信じている。

まず、MIT/NewJerseyアプローチの区別が妥当なものであり、それぞれの側が自分の方が優れていると信じていることを示すことから始めよう。

あるとき、MIT出身とBerkeley出身(ただし、Unix開発に携わっていた)の二人の有名人がOSの問題を話し合うために集まった。MITの彼はITS(MIT人工知能研究所のOS)に精通しており、Unixのソースコードを読んでいた。彼はUnixがどのように「PCloser-ing」問題を解決できるかに興味を持った。「PCloser-ing」問題はユーザプログラムがI/Oバッファのような状態を内部に持つ、時間のかかる操作をシステムに要求したときに起こる。もし実行中の操作が中止されると、ユーザプログラムの状態は保存される必要がある。しかしシステムの提供するそうしたルーチンは通常1つの命令であるため、ユーザプログラムの現在の命令の実行位置を示すプログラムカウンタ(PC)はプロセスが中止を受けたことを把握することができない。そこでシステムはその命令が実行される前に戻るか、そのまま命令を実行したことにして先に進むかしなければならない。「正しい」やり方はもちろん、命令の実行前まで戻ってプログラムカウンタをもとの位置に戻し、ユーザプログラムがその後システムルーチンの再実行などができるようにすることである。
プログラムカウンタがユーザモード(MITではユーザ(user)のことを皮肉をこめて敗者(loser)と呼ぶ)に強制的に戻されることから、このことを「PCloser-ing」と呼ぶ。

MITの彼は読んでいたUnixのソースの中にこの問題に対処するコードを見つけられなかったので、NewJersey側の彼にどうやってこの問題に対処しているのか尋ねた。NewJerseyの彼は、Unixを使っている人はこの問題に気付いているが、解決はシステムルーチンを中止を受けてもつねに終了させ、かわりにそのシステムルーチンが実行されなかったことを示すエラーを返すようにすることだと答えた。したがって、正しいユーザのプログラムはエラーがあるかをチェックしてそのシステムルーチンを再実行するかどうか自分で決めるものだと彼は言った。
MITの彼はこの解決は気に入らなかったが、それはもちろんこの解決が「正しい」やり方ではないからだった。

NewJerseyの彼は、このUnixの解決は正しい、なぜならUnixの設計哲学は単純さにあるのであって、「正しい」ことをするのは複雑過ぎるからだと言った。それだけでなく、プログラマがここにこの余分なテストとループのコードを入れることは簡単なことだと。

MITの彼はそれに対して、実装は簡単だが使用法が複雑すぎることを指摘した。NewJerseyの彼は、ここではUnixの設計哲学に従って適切なトレードオフが行われていると答えた。すなわち、実装の簡単さの方が使用法の簡単さより重要なのだと。

ここで私は、「悪い方がよい」原則の方がよりよい原則であると主張したい。CはUnixを書くためにデザインされたものであり、NewJerseyアプローチに従ってデザインされている。従ってCはそれなりに動くコンパイラが書きやすい言語だが、同時にそれはプログラマがコンパイラに読みやすいようにコードを書くことを要求する。Cのことを素敵なアセンブラだと呼んだ人もいるほどである。初期のUnixとCコンパイラはどちらも単純な構造を持っており、ハード的資源の少ないマシンにも容易に移植することができ、OSとプログラミング言語に対して望む働きの50%―80%程度を満たすことができた。

ある時点で存在するコンピュータの半分は標準的なコンピュータより遅いかメモリが少ないが、UnixとCはそういう機械でも問題なく動く。「悪い方がよい」という原則は実装の簡単さに何よりの重きを置くものであるから、それはUnixとCがそういう機械にも容易に移植できることを保証するわけである。従って、望まれることの50%の機能を持つUnixとCで充分なのであれば、それらは至るところに広まることになる。そして実際そうなってきた。

UnixとCは究極のコンピュータウイルスである。

「悪い方がよい」アプローチのさらなる利点は、プログラマが安全性や便利さを犠牲にし、かわりに、速く、システム資源をあまり消費しないプログラムを書くように強いられることである。NewJerseyアプローチを使って書かれたプログラムは小さいコンピュータでも大きなコンピュータでも同様に動き、プログラムは容易に移植が可能なものとなる─なぜならそれはウイルスの上に書かれているのだから!。

ただし、最初の「ウイルス」が基本的にはよいものでなければならないことは覚えておかなければならない。もしそうであれば、移植できるかぎりそのウイルスが広まっていくことは保証される。一度ウイルスが広まってしまえば、それをよりよいものにしようという動きが生まれ、そしてその機能は望まれる90％まで達していくだろう。しかしユーザは正しいものより悪いものを使い続けるようにすでに運命付けられてしまっているのだ。従って，「悪い方がよい」原則によるソフトウェアは最初に多くの人に受け入れられ、次にユーザがそれに多くを望まない状況に追い込み、最後に「正しい」プログラムとほとんど同じ機能を持つ所まで改善が続けられることになるのである。
具体例を挙げるなら、1987年の時点ではまだLispコンパイラはCコンパイラと同等の性能を持っていたが，その後ではCコンパイラを改善しようとする人々の方がLispコンパイラを改善しようとする人々よりずっと多かったのだ。

1995年に実現するだろう幸せは我々がよいOSとよいプログラミング言語を持つことであり、不幸はそれがUnixとC++となるだろうことである。

「悪い方がよい」原則にはまだ最後によい点がある。NewJerseyアプローチによる言語とシステムは単一の複雑なソフトウェアを構築するには力不足であるため、大きなシステムはそれを構成要素に分けて再利用を図る設計にならざるを得ないのである。そこで、要素を統合してシステムを作る伝統が作られることになる。

では、「正しい」アプローチはどうしてしまったのだろうか？そのたどるシナリオは２つある：『複雑巨大システム』に至るシナリオと『ダイヤモンドのような貴石』となるシナリオとである。

『複雑巨大システム』となるシナリオはこうなる：

まず最初に、正しいものごとはデザインされなければならない。それから、その実装もデザインされなければならない。ついに、それは実装される。それは正しいものだから、もちろん望まれる機能のほとんど100％を果たす。実装の単純さは決して考慮に入れられることはない、なぜなら正しいものを実装するには長い時間が必要だからである。それは大きく、複雑なものになる。それをうまく使うには，複雑な道具が必要になる。実装の最後の20％が努力の80％を費やし、リリースするには長い時間が必要となる。そしてそれはもっとも進んだハードの上だけで満足に動作する。

『ダイヤモンドの輝きを放つ貴石』となるシナリオはこうなる：

「正しい」ものをデザインするには無限の時間がかかるが、その途中ではそれはいつもきわめて小さなものになる。それを速く走るように実装するのは不可能か、ほとんどの実装者の能力を超えている。

この2つのシナリオはそれぞれCommonLispとSchemeのたどった道である。
また、最初のシナリオは古典的な人工知能プログラムのたどった道でもある。

「正しい」ソフトウェアはよく単一のモジュールからなるが、これは「正しい」ことがよく単一の視点で設計されるというだけのことである。これは偶然にすぎない。

このことから学ぶべき教訓は、最初に「正しい」方法をとることはしばしば望ましくないということである。とりあえず「正しい」ことの半分はできるものを作り、ウイルスのように広める方がよい。いったん人々がそれに騙されれば、「正しい」ことの90％までできるように改善が行われるだろう。

間違った教訓はこの寓話を文字通りにとって、人工知能プログラムにとってCが正しい言語だと早合点することである。50％の機能は正しいものでなければならなかったが、この場合はそうではない。しかし、LispコミュニティはLispデザインにおけるその地位を考え直さねばならないということはいえよう。このことについてはもう少し後で述べようと思う。

# 引用
http://chasen.org/~daiti-m/text/worse-is-better-ja.html
